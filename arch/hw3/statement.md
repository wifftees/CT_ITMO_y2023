# Домашнее задание 3

## Дедлайн

24 декабря 23:59 (UTC + 3).

Целью этого домашнего задания является реализация простого однотактного процессора, который реализует
маленькое модмножество архитектуры MIPS, с помощью Verilog.

## **DISCLAMER**

При реализации данного домашнего задания **запрещается** переименовывать порты модулей, сами модули
и названия файлов, в которых они лежат, иначе вы ССЗБ.

Разрешается изменение типов портов, например с `output [31:0] port` на `output reg [31:0] port`.

В данном домашнем задании нет никаких ограничений на использование фичей из Verilog'а.

## Структура процессора

Часть модулей, необходимых для реализации процессора уже реализована в файлах:
1) Память команд и данных, модуль [memory.v](./memory.v)
2) Регистровый файл, модуль [register_file.v](./register_file.v)
3) Модуль для одиночного 32-битного регистра PC в [d_flop.v](./d_flop.v)
4) Модуль [util.v](./util.v) содержит вспомогательные модули, которые могут быть полезны
   при реализации процессора.

Чтение из памяти и регистрового файла асинхронное, запись происходит по фронту сигнала синхронизации.

Обратите внимание, что память команд изначально заполняется двоичными данными из файла и является read-only.

Память данных и регистры изначально заполнены нулями.

Вашей задачей является реализация управляющего устройства и соединение всех остальных модулей
в работающий процессор.

Сам процессор необходимо реализовывать в модуле [mips_cpu.v](./mips_cpu.v). Для упрощения
процесса тестирования процессор взаимодействует с регистром PC, памятью команд и данных, а также регистровым
файлом через входные/выходные порты.
Пример использования этого процессора можно найти в файле [cpu_test.v](./cpu_test.v),
в этом файле также находится простейший тестовый сценарий, который выполняет заданное количество инструкций, а затем
выводит содержимое регистров и памяти данных.

Примеры двоичного кода для запуска можно найти в [programs_samples](./programs_samples/README.md).


## Часть 1. Реализация базовых инструкций.

В базовой части этого домашнего задания вам необходимо реализовать процессор, который реализует инструкции
`lw`, `sw`, `add`, `sub`, `and`, `or`, `slt`, `beq`.

Команды кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| lw      | 100011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| sw      | 101011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| beq     | 000100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

| Команда | opcode | rs    | rt    | rd    | shamt | funct  |
|---------|--------|-------|-------|-------|-------|--------|
| add     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100000 |
| sub     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100010 |
| and     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100100 |
| or      | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100101 |
| slt     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 101010 |

Напонимание: биты нумеруются справа налево, т.е. самый правый бит является самым младшим битом команды:)

Данная часть оценивается в 8 баллов (по баллу за каждую инструкцию).

## Часть 2. Реализация дополнительных инструкций I-типа

В данной части необходимо дополнительно реализовать инструкции `addi`, `andi`, `bne`.

Они кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| addi    | 001000 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| andi    | 001100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| bne     | 000101 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

Данная часть оценивается в 4 балла: `addi` стоит 2 балла, `andi` и `bne` по 1 баллу.

### Часть 3. Реализация инструкций J-типа.

В данной части необходимо дополнительно реализовать инструкции `j`, `jal`.

Они кодируются следующим образом:

| Команда | opcode | addr                       |
|---------|--------|----------------------------|
| j       | 000010 | xxxxxxxxxxxxxxxxxxxxxxxxxx |
| jal     | 000011 | xxxxxxxxxxxxxxxxxxxxxxxxxx |

`addr` определяет новый PC следующим образом: `pc_new <- {(PC + 4)[31:28], addr, 00}`

Данная часть оценивается в 4 балла, по 2 балла за реализацию каждой инструкции.

Инструкция `jr`, изменяет PC на значение, хранимое в регистре с номером переданным в
`rs`.

| Команда | opcode | rs    | rt    | rd    | shamt | funct  |
|---------|--------|-------|-------|-------|-------|--------|
| jr      | 000000 | xxxxx | 00000 | 00000 | 00000 | 001000 |

Еще 2 балла.

## Формат сдачи

`.zip` архив с файлами решения (`mips_cpu.v`, а также все дополнительные модули, которые он include'ит,
например `util.v`) необходимо прислать в [гугл форму](https://forms.gle/SCmbCRm2ejDPHK3V8).
